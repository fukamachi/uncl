(in-package :uncl)

(let ( (r (copy-readtable nil)) )
  (defun read-symbol (stream)
    (let ( (*readtable* r) )
      (read-preserving-whitespace stream))))

(defun symbol-reader-macro-reader (stream char)
  (unread-char char stream)
  (let* ((s (read-symbol stream))
         (f (get s 'symbol-reader-macro)))
    (if f (funcall f stream s) s)))

(defun set-macro-symbol (symbol readfn)
  (setf (get symbol 'symbol-reader-macro) readfn)
  t)

(defmacro define-macro-symbol (from to)
  `(set-macro-symbol ',from
                     #'(lambda (stream symbol)
                         (declare (ignore stream symbol))
                         ',to)))

(defparameter aliases
  '((def defvar)
    (call funcall)
    (y/n? y-or-n-p)
    (append! nconc)
    (reverse! nreverse)
    (set! setf)
    (inc! incf)
    (dec! decf)
    (push! push)
    (pop! pop)
    (zero? zerop)
    (complex? complexp)
    (rational? rationalp)
    (real? realp)
    (float? floatp)
    (integer? integerp)
    (constant? constantp)
    (number? numberp)
    (plus? plusp)
    (minus? minusp)
    (even? evenp)
    (odd? oddp)
    (symbol? symbolp)
    (keyword? keywordp)
    (function? functionp)
    (string? stringp)
    (list? listp)
    (cons? consp)
    (array? arrayp)
    (vector? vectorp)
    ))

(defun defalias (to from)
  (cond
    ((macro-function from)
     (setf (macro-function to) (macro-function from)))
    ((symbol-function from)
     (setf (symbol-function to) (symbol-function from)))
    (t (define-macro-symbol from to))))

(defun init-readtable ()
  (map nil (lambda (c)
             (set-macro-character c 'symbol-reader-macro-reader t))
       "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_")

  ;; special forms
  (define-macro-symbol if aif)
  (define-macro-symbol cond acond2)
  (define-macro-symbol fn lambda)
  (define-macro-symbol let let2)
  (define-macro-symbol do progn)

  ;; functions
  (dolist (alias aliases)
    (apply #'defalias alias))

  (enable-escape-sequence))
